«IMPORT it::xtypes::typesystem»

«EXTENSION xtypes::extensions::Extensions»
«EXTENSION xtypes::extensions::Types»
«EXTENSION xtypes::extensions::Validator»

«DEFINE main FOR TypeSystemDefinition-»
«LET this.name.toFirstUpper() + "TypeSystemValidator" AS className»
«FILE packageToDir(this.getGeneratedTypeSystemValidatorPackage()) + "/"  
	+ className + ".java"-»
package «this.getGeneratedTypeSystemValidatorPackage()»;

import java.util.ArrayList;
import java.util.List;

import org.eclipse.emf.ecore.EClassifier;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.validation.Check;

import com.google.inject.Inject;

import it.xtypes.runtime.AbstractTypeSystemDeclarativeValidator;
import it.xtypes.runtime.TypingJudgmentEnvironment;
import it.xtypes.typesystem.ExpressionType;

import «getCurrentModelPackage()».«this.getPackageName()»;

import «this.getGeneratedTypesystemPackage()».«this.name.toFirstUpper() + "TypeSystemDefinition"»;

/**
 * Automatically generated by XTypeS, http://xtypes.sourceforge.net
 * Do not modify it.
 * This class should be instantiated with Google Guide injector.
 */
public class «className» extends AbstractTypeSystemDeclarativeValidator {
	@Inject
	protected «this.name.toFirstUpper() + "TypeSystemDefinition"» typeSystem;

	protected «this.getPackageName()» basicPackage = «this.getPackageName()».eINSTANCE;

	@Override
	protected List<EPackage> getEPackages() {
	    List<EPackage> result = new ArrayList<EPackage>();
	    result.add(«getCurrentModelPackage()».«this.getPackageName()».eINSTANCE);
		return result;
	}

    protected ExpressionType createBasicType(String basic) {
        return typeSystem.createBasicType(basic);
    }

    protected ExpressionType createEClassifierType(EClassifier eClassifier) {
        return typeSystem.createEClassifierType(eClassifier);
    }

    protected ExpressionType createCollectionType(ExpressionType expressionType) {
        return typeSystem.createCollectionType(expressionType);
    }
    
	«EXPAND checkMethod FOREACH this.collectCheckRules()»
}
«ENDFILE-»
«ENDLET»
«ENDDEFINE»

«DEFINE checkMethod FOR Rule»
«LET this.containingTypeSystem.getJudgmentDescription(
	this.typejudgment.typejudgmentsymbol,this.typejudgment.typingstatement.relation) AS judgmentDescription»
«IF judgmentDescription != null»
public static final String
	«judgmentDescription.kind.validatorStringConstant(this.getLeftType())» 
	= "«judgmentDescription.kind.validatorStringConstantValue(this.getLeftType())»";

@Check
public 
void 
check«this.typejudgment.typingstatement.left.getExpressionType().getTypeNameDesc()»«judgmentDescription.kind.toFirstUpper()»
(«this.typejudgment.typingstatement.left.getExpressionType().getQualifiedTypeName()» object) {
	generateErrors(typeSystem.tryToApply(«judgmentDescription.kind»EnvironmentFor(object),
		"«judgmentDescription.judgmentsymbol»", "«judgmentDescription.relation»",
		«EXPAND Variable::createType FOR this.getLeftType()»,
		«EXPAND Variable::createType FOR this.getRightType()»,
		object), object, «judgmentDescription.kind.validatorStringConstant(this.getLeftType())»);
}

protected TypingJudgmentEnvironment «judgmentDescription.kind»EnvironmentFor(«this.typejudgment.typingstatement.left.getExpressionType().getQualifiedTypeName()» object) {
	return getDefaultTypingJudgmentEnvironmentFor(object);
}
«ENDIF»
«ENDLET»
«ENDDEFINE»