/*
 * generated by Xtext
 */
package it.xtypes.ui.outline;

import java.util.List;

import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.jface.viewers.ILabelProvider;
import it.xtypes.typesystem.Axiom;
import it.xtypes.typesystem.Exists;
import it.xtypes.typesystem.ForAll;
import it.xtypes.typesystem.ForEach;
import it.xtypes.typesystem.OrBranch;
import it.xtypes.typesystem.OrTypingJudgment;
import it.xtypes.typesystem.Quantification;
import it.xtypes.typesystem.RuleWithPremises;
import it.xtypes.typesystem.TypingJudgmentWithEnvironment;
import it.xtypes.typesystem.TypingJudgment;
import org.eclipse.xtext.ui.editor.outline.ContentOutlineNode;
import org.eclipse.xtext.ui.editor.outline.OutlineLabelProvider;
import org.eclipse.xtext.ui.editor.outline.transformer.AbstractDeclarativeSemanticModelTransformer;

import com.google.inject.Inject;

/**
 * customization of the default outline structure
 * 
 */
public class TypeSystemTransformer extends
		AbstractDeclarativeSemanticModelTransformer {
	@Inject
	@OutlineLabelProvider
	private ILabelProvider labelProvider;

	/**
	 * Ensures that the passed string is not null
	 * @param node
	 * @param label
	 */
	protected void setNodeLabel(ContentOutlineNode node, String label) {
		if (label != null)
			node.setLabel(label);
	}
	
	public ContentOutlineNode createNode(SingleTypingJudgment typingJudgment,
			ContentOutlineNode parentNode) {
		ContentOutlineNode node = super.createNode(typingJudgment, parentNode);
		setNodeLabel(node, labelProvider.getText(typingJudgment.getTypingstatement()));
		return node;
	}

	public ContentOutlineNode createNode(OrTypingJudgment orTypingJudgment,
			ContentOutlineNode parentNode) {
		ContentOutlineNode or = new ContentOutlineNode("or");
		parentNode.getChildren().add(or);
		for (OrBranch branch : orTypingJudgment.getBranches()) {
			ContentOutlineNode branchNode = new ContentOutlineNode("branch");
			or.getChildren().add(branchNode);
			createElementsForTypingJudgments(branch.getJudgments(), branchNode);
		}

		return or;
	}

	protected void createElementsForTypingJudgments(
			EList<TypingJudgment> typingJudgments, ContentOutlineNode node) {
		for (TypingJudgment typingJudgment : typingJudgments) {
			createOutlineNode(typingJudgment, node);
		}
	}

	public ContentOutlineNode createNode(ForEach forEach,
			ContentOutlineNode parentNode) {
		return nodeForLoop(forEach, "foreach", parentNode);
	}

	public ContentOutlineNode createNode(ForAll forAll,
			ContentOutlineNode parentNode) {
		return nodeForLoop(forAll, "forall", parentNode);
	}

	public ContentOutlineNode createNode(Exists exists,
			ContentOutlineNode parentNode) {
		return nodeForLoop(exists, "exists", parentNode);
	}

	protected ContentOutlineNode nodeForLoop(Quantification quantification, String name,
			ContentOutlineNode parentNode) {
		ContentOutlineNode loopnode = new ContentOutlineNode(name);
		parentNode.getChildren().add(loopnode);
		for (TypingJudgment typingJudgment : quantification.getJudgments()) {
			createOutlineNode(typingJudgment, loopnode);
		}

		return loopnode;
	}

	public ContentOutlineNode createNode(RuleWithPremises ruleWithPremises,
			ContentOutlineNode parentNode) {
		ContentOutlineNode node = super
				.createNode(ruleWithPremises, parentNode);
		EList<TypingJudgment> judgments = ruleWithPremises.getPremises();
		if (judgments != null) {
			ContentOutlineNode premises = new ContentOutlineNode("premises");
			node.getChildren().add(premises);
			for (TypingJudgment typingJudgment : judgments) {
				createOutlineNode(typingJudgment, premises);
			}
		}
		if (ruleWithPremises.getTypejudgment() != null) {
			ContentOutlineNode derives = new ContentOutlineNode("derives");
			node.getChildren().add(derives);
			createOutlineNode(ruleWithPremises.getTypejudgment(), derives);
		}

		return node;
	}

	public ContentOutlineNode createNode(Axiom axiom,
			ContentOutlineNode parentNode) {
		ContentOutlineNode node = super.createNode(axiom, parentNode);
		if (axiom.getTypejudgment() != null) {
			createOutlineNode(axiom.getTypejudgment(), node);
		}

		return node;
	}

	public List<EObject> getChildren(SingleTypingJudgment typingJudgment) {
		return NO_CHILDREN;
	}

	public List<EObject> getChildren(RuleWithPremises rule) {
		return NO_CHILDREN;
	}

	public List<EObject> getChildren(Axiom rule) {
		return NO_CHILDREN;
	}
}
