can refer to platform plugins?
typesystem FJ
grammar "platform:/plugin/org.eclipse.xtext.example.fj/src-gen/org/eclipse/xtext/example/FJ.ecore"
yes, but then the generator will fail


one could add to the generator

bean = StandaloneSetup {
		platformUri = ".."
	}
bean = StandaloneSetup {
		platformUri = "../.."
	}

to refer to many platform uris


In launch configurations, put in VM arguments
-XX:PermSize=256M -XX:MaxPermSize=512M
in case there are PermGen out of memory errors.


axiom TTerm
	G |- var Term term : var Type t

axiom TIntConstant
	G |- var IntConstant i : var IntType int

axiom TStringConstant
	G |- var StringConstant s : var StringType string
	
does not work if we ask for the Type of an IntConstant:
we pass an IntConstant and a Type, thus we match TTerm and not
TIntConstant, since Type is not a subtype of IntType

This is the working version:

// not used
axiom TTerm
	G |- var Term term : var Type t

rule TIntConstant
derives
	G |- var IntConstant i : var Type int
from
	var IntType intType
	$int := $intType

rule TStringConstant
derives
	G |- var StringConstant s : var Type string
from
	var StringType stringType
	$string := $stringType


The most specific rules must come later, e.g.,

	G |- var Type t1 == var ArrowType a2

	G |- var ArrowType a2 == var Type t1

	G |- var ArrowType a1 == var ArrowType a2

@Check
	public void checkExpressionType(
			org.eclipse.xtext.example.fj.Expression object) {
		generateErrors(typeSystem.tryToApply(null, "|-", ":",
				typeSystem.createEClassifierType(basicPackage.getExpression()),
				typeSystem.createBasicType("String"), object));
	}

also catches the case for This!
Thus for check rules we should avoid using a base rule


in the test make sure that every dummy resource has a unique name

public Resource loadFromString(String program) throws IOException {
		Resource resource = resourceSet.createResource(URI
				.createURI("dummy:/example" + (++programUID) + ".typesystem"));
		InputStream in = new ByteArrayInputStream(program.getBytes());
		resource.load(in, resourceSet.getLoadOptions());
		return resource;
	}

To deal with root elements without name in the root:

public class MyQNP extends DefaultDeclarativeQualifiedNameProvider {
    
    public String qualifiedName(Model model) {
        return model.eResource().getURI().toString();
    }

}



public class MyDslRuntimeModule extends org.xtext.example.mydsl.AbstractMyDslRuntimeModule {

    @Override
    public Class<? extends IQualifiedNameProvider> bindIQualifiedNameProvider() {
        return MyQNP.class;
    }
    
}



module workflow.MyDslGenerator

import org.eclipse.emf.mwe.utils.*

var targetDir = "src-gen"
var fileEncoding = "Cp1252"
var modelPath = "src/model"

Workflow {

    component = org.eclipse.xtext.mwe.Reader {
        // lookup all resources on the classpath
        // useJavaClassPath = true

        // or define search scope explicitly
        path = modelPath

        // this class will be generated by the xtext generator         register = org.xtext.example.mydsl.MyDslStandaloneSetup {}
        load = {
            slot = "model"
            type = "Model"
        }
    }

    component = org.eclipse.xpand2.Generator {
        expand = "templates::Template::main FOREACH model"
        outlet = {
            path = targetDir
        }
        fileEncoding = fileEncoding
    }
}

