package it.xtypes.runtime;

import it.xtypes.runtime.util.AuxiliaryFunctionsRuntime;
import it.xtypes.typesystem.ExpressionType;

import java.util.List;

import org.eclipse.emf.ecore.EClassifier;
import org.eclipse.emf.ecore.EObject;

/**
 * The runtime version of a type system rule. This is an abstract class;
 * concrete subclasses will be generated by the generator.
 * 
 * @author Lorenzo Bettini
 * 
 */
public abstract class RuntimeRule {

	protected String ruleName;

	protected String typeJudgmentSymbol;

	protected String typeStatementRelation;

	protected RuntimeTypeSystem runtimeTypeSystem;

	protected RuleApplicationTrace ruleApplicationTrace = new RuleApplicationTrace();

	public RuntimeRule(String ruleName, String typeJudgmentSymbol,
			String typeStatementRelation) {
		super();
		this.ruleName = ruleName;
		this.typeJudgmentSymbol = typeJudgmentSymbol;
		this.typeStatementRelation = typeStatementRelation;
	}

	public String getRuleName() {
		return ruleName;
	}

	public void setRuleName(String ruleName) {
		this.ruleName = ruleName;
	}

	public String getTypeJudgmentSymbol() {
		return typeJudgmentSymbol;
	}

	public String getTypeStatementSymbol() {
		return typeStatementRelation;
	}

	public RuntimeTypeSystem getRuntimeTypeSystem() {
		return runtimeTypeSystem;
	}

	public void setRuntimeTypeSystem(RuntimeTypeSystem runtimeTypeSystem) {
		this.runtimeTypeSystem = runtimeTypeSystem;
	}

	public RuleApplicationTrace getRuleApplicationTrace() {
		return ruleApplicationTrace;
	}

	public abstract TypingJudgmentEnvironment getEnvironment();

	public abstract void setEnvironment(TypingJudgmentEnvironment environment);

	protected <T> T castto(Object exp, Class<T> clazz)
			throws RuleFailedException {
		ruleApplicationTrace.add(stringRep(exp) + " cast to "
				+ stringRep(clazz));
		return runtimeTypeSystem.castto(exp, clazz);
	}

	protected int length(Object object) throws RuleFailedException {
		return runtimeTypeSystem.length(object);
	}

	protected boolean equals(Object left, Object right)
			throws RuleFailedException {
		ruleApplicationTrace.add(stringRep(left) + " equals "
				+ stringRep(right));
		return runtimeTypeSystem.equals(left, right);
	}

	protected boolean notEquals(Object left, Object right)
			throws RuleFailedException {
		ruleApplicationTrace.add(stringRep(left) + " not equals "
				+ stringRep(right));
		return runtimeTypeSystem.notEquals(left, right);
	}

	@SuppressWarnings("rawtypes")
	protected void assignment(Variable var, Object right) {
		runtimeTypeSystem.assignment(var, right);
	}

	protected <T> List<T> getAll(EObject eObject, String mainFeature,
			String extendFeature, Class<T> type) throws RuleFailedException {
		return runtimeTypeSystem.getAll(eObject, mainFeature, extendFeature);
	}

	protected Object env(TypingJudgmentEnvironment environment, Object key)
			throws RuleFailedException {
		return runtimeTypeSystem.env(environment, key);
	}

	protected TypingJudgmentEnvironment union(TypingJudgmentEnvironment e1,
			TypingJudgmentEnvironment e2) throws RuleFailedException {
		return runtimeTypeSystem.union(e1, e2);
	}

	protected TypingJudgmentEnvironment union(TypingJudgmentEnvironment e1,
			RuntimeEnvironmentEntry e2) throws RuleFailedException {
		return runtimeTypeSystem.union(e1, e2);
	}

	protected TypingJudgmentEnvironment union(RuntimeEnvironmentEntry e2,
			TypingJudgmentEnvironment e1) throws RuleFailedException {
		return runtimeTypeSystem.union(e1, e2);
	}

	protected TypingJudgmentEnvironment union(RuntimeEnvironmentEntry e1,
			RuntimeEnvironmentEntry e2) throws RuleFailedException {
		return runtimeTypeSystem.union(e1, e2);
	}

	protected TypingJudgmentEnvironment envListCons(
			TypingJudgmentEnvironment head, TypingJudgmentEnvironment tail) {
		return runtimeTypeSystem.envListCons(head, tail);
	}

	protected TypingJudgmentEnvironment envListCons(
			TypingJudgmentEnvironment head, RuntimeEnvironmentEntry tail) {
		return runtimeTypeSystem.envListCons(head, tail);
	}

	protected TypingJudgmentEnvironment envListCons(
			RuntimeEnvironmentEntry head, TypingJudgmentEnvironment tail) {
		return runtimeTypeSystem.envListCons(head, tail);
	}

	protected String newName(String value) {
		return runtimeTypeSystem.newName(value);
	}

	protected <T> T clone(T object) {
		return runtimeTypeSystem.clone(object);
	}

	protected <T> List<T> clone(List<T> list) {
		return runtimeTypeSystem.clone(list);
	}

	protected EObject container(EObject object) throws RuleFailedException {
		return runtimeTypeSystem.container(object);
	}

	protected void fail(String message) throws RuleFailedException {
		throw new RuleFailedException(message);
	}

	protected void applyRule(TypingJudgmentEnvironment environment,
			String typingJudgmentSymbol, String typeStatementRelation,
			Object left, Object right) throws RuleFailedException {
		RuntimeRule applied = runtimeTypeSystem.applyRule(environment,
				typingJudgmentSymbol, typeStatementRelation, left, right);
		addAppliedRuleToTrace(applied);
	}

	/**
	 * @param applied
	 */
	protected void addAppliedRuleToTrace(RuntimeRule applied) {
		ruleApplicationTrace.addApplied(applied);
	}

	public void apply() throws RuleFailedException {
		try {
			ruleApplicationTrace.addMain(this);
			applyImpl();
		} catch (RuleFailedException e) {
			registerFailure(e);
			throw new RuleFailedException(ruleFailureMessage(), getLeft(),
					getRight(), e);
		} catch (ClassCastException e) {
			throw new RuleFailedException("cast exception " + e.getMessage(),
					getLeft(), getRight());
		}
	}

	/**
	 * A default implementation of rule failure message
	 * 
	 * @return an error string when this rule fails
	 */
	protected String ruleFailureMessage() {
		return "rule " + getRuleName() + " " + failMessage() + ": "
				+ toString();
	}

	protected String failMessage() {
		return "failed";
	}

	/**
	 * Adds a failure checkpoint in the application trace
	 */
	protected void register(String message) {
		ruleApplicationTrace.add(message);
	}

	/**
	 * Adds a failure checkpoint in the application trace
	 */
	protected void registerFailure() {
		ruleApplicationTrace.add("FAILED");
	}

	/**
	 * Adds a failure checkpoint in the application trace
	 */
	protected void registerFailure(RuleFailedException e) {
		ruleApplicationTrace.addFailure(e);
	}

	protected void registerAndThrowFailure(Throwable e)
			throws RuleFailedException {
		if (e instanceof RuleFailedException) {
			RuleFailedException ruleFailedException = (RuleFailedException) e;
			registerFailure(ruleFailedException);
			throw ruleFailedException;
		}
		throw new RuleFailedException(e);
	}

	protected void registerFailure(Throwable e) {
		if (e instanceof RuleFailedException) {
			RuleFailedException ruleFailedException = (RuleFailedException) e;
			registerFailure(ruleFailedException);
		}
	}

	protected String stringRep(Object object) {
		return runtimeTypeSystem.stringRep(object);
	}

	@Override
	public String toString() {
		String envRep = (getEnvironment() == null ? ""
				: stringRep(getEnvironment()));
		return (envRep.length() > 0 ? envRep + " " : "")
				+ getTypeJudgmentSymbol() + " " + stringRep(getLeft()) + " "
				+ getTypeStatementSymbol() + " " + stringRep(getRight());
	}

	protected ExpressionType createBasicType(String basic) {
		return AuxiliaryFunctionsRuntime.createBasicType(basic);
	}

	protected ExpressionType createEClassifierType(EClassifier eClassifier) {
		return AuxiliaryFunctionsRuntime.createEClassifierType(eClassifier);
	}

	protected ExpressionType createCollectionType(ExpressionType expressionType) {
		return AuxiliaryFunctionsRuntime.createCollectionType(expressionType);
	}

	protected RuntimeEnvironmentEntry newRuntimeEnvironmentEntry(Object left,
			Object right) {
		return new RuntimeEnvironmentEntry(left, right);
	}

	/**
	 * The implementation of the application of the rule (typically generated
	 * automatically)
	 * 
	 * @return
	 * @throws RuleFailedException
	 */
	public abstract void applyImpl() throws RuleFailedException;

	/**
	 * Returns the variable representing the left expression in the final typing
	 * judgment
	 * 
	 * @return
	 */
	@SuppressWarnings("rawtypes")
	public abstract Variable getLeft();

	/**
	 * Returns the variable representing the right expression in the final
	 * typing judgment
	 * 
	 * @return
	 */
	@SuppressWarnings("rawtypes")
	public abstract Variable getRight();

	/**
	 * Creates a new instance for this rule
	 * 
	 * @return
	 */
	public abstract RuntimeRule newInstance();
}
