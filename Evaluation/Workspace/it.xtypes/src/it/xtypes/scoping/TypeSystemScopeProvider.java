/*
 * generated by Xtext
 */
package it.xtypes.scoping;

import it.xtypes.typesystem.CompoundExpression;
import it.xtypes.typesystem.Expression;
import it.xtypes.typesystem.GetAll;
import it.xtypes.typesystem.TypeSystemDefinition;
import it.xtypes.typing.ExpressionTypingSystem;
import it.xtypes.util.ScopedVariablesCollector;

import java.util.LinkedList;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;
import org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider;

import com.google.inject.Inject;

/**
 * This class contains custom scoping description.
 * 
 * see : http://www.eclipse.org/Xtext/documentation/latest/xtext.html#scoping on
 * how and when to use it
 * 
 */
public class TypeSystemScopeProvider extends AbstractDeclarativeScopeProvider {

	@Inject
	protected ExpressionTypingSystem typingSystem;

	@Inject
	protected ENamedElementCollector eNamedElementCollector;

	@Inject
	protected ScopedVariablesCollector scopedVariablesCollector;

	@Override
	public IScope getScope(EObject context, EReference reference) {
		// TODO Auto-generated method stub
		return super.getScope(context, reference);
	}

	/**
	 * The scope for an EClassifier is simply all the classifiers defined in the
	 * referenced package
	 * 
	 * @param typeSystemDefinition
	 * @param reference
	 * @return
	 */
	public IScope scope_EClassifier(TypeSystemDefinition typeSystemDefinition,
			EReference reference) {
		EPackage ePackage = typeSystemDefinition.getEPackage();
		if (ePackage == null)
			return Scopes.scopeFor(new LinkedList<EObject>());
		return Scopes.scopeFor(ePackage.getEClassifiers());
	}

	/**
	 * Only the variables in the scope of the expression
	 * 
	 * @param expression
	 * @param reference
	 * @return
	 */
	public IScope scope_VariableDeclaration(Expression expression,
			EReference reference) {
		return Scopes.scopeFor(scopedVariablesCollector
				.collectVariablesInScope(expression));
	}

	/**
	 * For a compound expression's subexpression the scope is all the structural
	 * features defined in the EClass of the main expression.
	 * 
	 * @param compoundExpression
	 * @param reference
	 * @return
	 */
	public IScope scope_SubExpression_feature(
			CompoundExpression compoundExpression, EReference reference) {
		return collectNamedElements(compoundExpression.getMainExpression());
	}

	public IScope scope_GetAll_mainfeature(GetAll getAll, EReference reference) {
		return collectNamedElements(getAll.getExpression());
	}

	public IScope scope_GetAll_extendfeature(GetAll getAll, EReference reference) {
		return collectNamedElements(getAll.getExpression());
	}

	/**
	 * Collects all the elements which are selectable on the passed exp. In case
	 * it's an EClass the scope consists of all its structural features. In case
	 * it's an EEnum the scope consists of all its literals.
	 * 
	 * @param exp
	 * @return
	 */
	public IScope collectNamedElements(Expression exp) {
		return Scopes.scopeFor(eNamedElementCollector.collect(typingSystem
				.getExpressionType(exp)));
	}

}
